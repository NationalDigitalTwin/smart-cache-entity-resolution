/**
 *   Copyright (c) Telicent Ltd.
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 */
package io.telicent.smart.cache.entity.sinks.converters;

import io.telicent.smart.cache.entity.Entity;
import io.telicent.smart.cache.entity.EntityData;
import io.telicent.smart.cache.entity.SecurityLabelledNode;
import org.apache.commons.collections4.MapUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.jena.graph.Node;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Stream;

/**
 * An entity to data converter that outputs as a simple map
 */
public class DataToSimpleMap extends AbstractEntityDataGroupConverter {
    private final boolean compactKeys;

    /**
     * Creates a new output converter
     *
     * @param outputField   Output field name
     * @param compactKeys   Whether to compact keys
     * @param compactValues Whether to compact values
     * @param group         Entity data group to be output
     */
    public DataToSimpleMap(String outputField, boolean compactKeys, boolean compactValues, String group) {
        super(outputField, compactValues, group);
        this.compactKeys = compactKeys;
    }

    @Override
    protected void populateSecurityLabels(Entity entity, Stream<EntityData> data, Map<String, Object> output) {
        // Nothing to do, security labels are directly output in the output map generated by getOutput()
    }

    @Override
    protected Object getOutput(Entity entity, Stream<EntityData> data) {
        Map<String, Object> map = new LinkedHashMap<>();
        Map<String, List<String>> securityLabels = new LinkedHashMap<>();

        data.forEach(d -> {
            String key = nodeToKey(entity, d.key());
            SecurityLabelledNode value = d.get();
            ((List<String>) map.computeIfAbsent(key, k -> new ArrayList<>()))
                    .add(nodeToString(entity, value));
            securityLabels.computeIfAbsent(key, k -> new ArrayList<>()).add(
                    value.hasSecurityLabel() ? value.getSecurityLabel() : "");
        });
        securityLabels.entrySet().removeIf(e -> e.getValue().stream().allMatch(StringUtils::isBlank));
        if (MapUtils.isNotEmpty(securityLabels)) {
            map.put(DefaultOutputFields.SECURITY_LABELS, securityLabels);
        }

        return map.isEmpty() ? null : map;
    }

    @Override
    protected boolean shouldOutputFineGrainedSecurityLabels(Entity entity, Stream<EntityData> data) {
        return false;
    }

    private String nodeToKey(Entity item, Node node) {
        if (node.isURI()) {
            return this.compactKeys && item.hasPrefixes() ? item.getPrefixes().shortForm(node.getURI()) : node.getURI();
        } else {
            return nodeToString(item, node);
        }
    }
}
